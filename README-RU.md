Генератор микроразметки
===

Генерация html-разметки на основе заданной модели данных.


Ошибки и ограничения валидаторов
---

Google:

- Нельзя использовать несколько элементов разметки ItemList на одной странице
- ItemList – недопустимый тип целевого объекта для свойства contactPoint
- contactType - HH (Значение hh должно содержать действительные контактные данные.) (replace to 'customer service' or smth else)

Яндекс:

- поле contactPoint содержит некорректный тип данных http://schema.org/ItemList. Допустимые типы данных http://schema.org/ContactPoint

- url required


Обязательные и опциональные свойства
---

Сущность описывается набором свойств. Например, сущность "Город" описывается:
- численность населения
- площадь

Если какой-то параметр неизвестен, устанавливается значение undefined|null

Важно различать **отсутствие значения параметра** и **отсутсвие самого параметра**.
Нам либо неизвестна численность населения, либо этот параметр вообще не учитывается в системе.

```
{
  popularity: undefined, // or null
  area: 100
}
```

В нормализованном виде все свойства сущности должны быть заполнены. Все опциональные свойства выносятся в отдельные сущности (one-to-one relationship). В реальных кейсах присутствуют опциональные свойства - для уменьшения сложности и увеличения производительности.


Отображение сущности
---

При отсутствии значений желательно корректно уведомлять пользователя.

```
<div>
  <span id="label">Popularity</span>
  <span id="value"></span>
</div>
```

Само сообщение об отсутсвии значения не содержится в модели. Его можно добавить с помощью представления, например, с помощью [CSS :empty selector](https://developer.mozilla.org/ru/docs/Web/CSS/:empty):

```
#value:empty:after {
  content: 'no value';
}
```

Использование специфичных тэгов
---

Если тип значения - "Ссылка", то при отсутствии значения невалидно будет указывать пустую ссылку:

```<a id="value" href=""></a>```

Один из вариантов: заменить тэг на тэг по умолчанию (a --> span). При этом надо скопировать все аттрибуты из прежнего тэга.

Валидатор микроразметки требует наличия href для значений-ссылок. Как хак, можно скрыть сам факт наличия свойства (удалить itemprop атрибут).


Документо-ориентированная модель
---

Один "Сервис" может иметь несколько "Предложений" (один ко многим)
Одно "Предложение" содержит ссылку на один "Сервис" (один к одному)
Одно "Предложение" содержит ссылку на одного "Продавца" (один к одному)
Один "Продавец" может иметь несколько "Предложений" (один ко многим)

Сущность "Предложение" является ассоциативной между "Сервисом" и "Продавцом"

На разных страницах эта модель может быть представлена с разной корневой сущностью:
- Продавец -> список предложений ( + сервисов)
- Сервис -> список предложений ( + продавцов)
- Предложение -> сервис и продавец


Перечень объектов
---

> Use markup for a specific product, not a category or list of products. For example, “shoes in our shop” is not a specific product. See also our [structured data policies](https://developers.google.com/search/docs/guides/intro-structured-data#multiple-entities-on-the-same-page) for multiple entities on the same page.

https://developers.google.com/search/docs/data-types/products

> A category page listing several different products (or recipes, videos, or any other type). Each entity should be marked up using the relevant schema.org type, such as schema.org/Product for product category pages. Marking up just one category entity from all listed on the page is against our guidelines.

https://blog.heppresearch.com/2015/07/09/google-product-rich-snippets-for-multiple-products-on-a-page/

> the main entity is a http://schema.org/SearchResultsPage type, linked to the seven offers via http://schema.org/offers. This is wrong, because the offers property for a http://schema.org/SearchResultsPage type is inherited from http://schema.org/CreativeWork and links to offers of the creative work.


Идентификатор сущности
---

Должны ли ДОМ-элементы содержать идентификаторы?

- itemtype + itemprop: доступ к конкретному свойству сущности заданного типа, например к свойству "заголовок" всех сущностей типа "рекламный блок" на странице
- если необходим доступ к конкретному "рекламному блоку", можно прописать всю иерархию от корневой сущности
- если необходим доступ к конкретному элементу из списка сущностей, можно использовать порядковый номер в списке. Если массив неупорядоченный


Стилизация генерируемых элементов
---

Каждый браузер имеет встроенные стили для HTML элементов, например:
- отступы в инпутах
- размер между строками в тексте
- специфичное отображение инпутов с датами

Генератор микроразметки также задаёт стили по умолчанию для многих элементов, например
- стилизация чекбокса для более удобного использования в мобильных браузерах
- скрытие дефолтного датапикера для инпутов с датами (обычно он заменяется на более удобную библиотку)

Все сущности состоят из представленных элементов и, соответственно, только внутри этих элементов отображаются все данные модели.

Обычно веб-страницы используют только часть из предложенных элементов. Подгружать все стили нецелесообразно (хотя и можно использовать пост-очистку, типа purifycss, но это двойная работа). Также и в случае клиентского ре-рендеринга неоптимально подгружать все скрипты.

Браузеры внутри себя содержат как и стили, так и скрипты для ВСЕХ элементов. Во многих случаях - это избыточно (например датапикер). Поддержка тех или иных элементов определяется разработчиками браузеров по принципу "если большая часть сайтов использует - то встроить компонент в ядро".
В данном генераторе действует то же правило: все компоненты содержат минимально необходимые стили и скрипты и включены в ядро. Плюс есть возможность подгружать только "display" элементы для страниц без форм и ввода данных. При острой необходимости разработчик может сам сгенерировать необходимый пакет, как это делается в http://getbootstrap.com/customize/


Взаимодействие с пользователем
---

Любая страница ориентирована на взаимодействие с пользователем. Даже если это статья - есть кнопки Поделиться/Нравится/Оценить/Коммент - данные из которых поступают на сервер, например сущность

ОценкаСтатьи
 - статья_ид
 - пользователь_ид
 - оценка
 - отзыв

Любой коммент - это по сути отзыв. Обычно один пользователь оставляет один отзыв к одной статье. Оценки (комменты) к самим отзывам - это другая сущность. В итоге сущность "ОценкаСтатьи" отправляется на сервер и сохраняется в БД.

Для отправки необходима форма. В теории, все элементы ввода (input, select) должны находится в html-форме. И должна быть возможность передавать значения на сервер без помощи javascript.

Сама статья является неизменяемой пользователями. Пользователь лишь указывает идентификатор статьи (при вводе ЮРЛ) и статья подгружается. То есть идентификатор статьи по сути является изменяемым. Идентификатор сущности - это по сути часть глобального идентификатора (ЮРЛ) этой же сущности. Например Person123 - mydomain/person123. По данному адресу и подгружается вся сущность.
В случае массива объектов, входящих в какую-либо корневую сущность - подгружаются все ИД объектов, а уже потом подгружаются отдельно все соответствующие сущности.

С точки зрения взаимодействия с пользователем, ключевая сущность любой страницы - это и есть форма ввода:
- для видео - сущность-форма "Комментарий"
- для поиска - сущность-форма "Заказ на поиск" (фраза, фильтры и т.п.)
- для товара - сущность-форма "Заказ товара"

Сущность-форма связана непосредственно с единственной целевой сущностью (услугой, продуктом, предложением и т.п.), например "Комментарий" привязан к "Видео". Эта целевая сущность является вычисляемой на основе внешнего ключа сущность-формы:

```
comment
 - id
 - text
 - video_id
 - video // calculated by video_id
    - id
    - headline
    - comments // other existing comments (readonly)
```

Вычисляемые поля целевой сущности являются неизменяемыми и не входят в состав html-формы.

URL адрес страницы обычно соответствует названию или идентификатору целевой сущности, например /book/happy-new-year


Совмещение свойств одной сущности
---

- ссылку и имя компании (a + name)
- ссылку и логотип компании (a + img + name)

{
  name: 'Super company',
  url: 'http://super.company',
  logo: {
    contentUrl: 'asdf',
    width: 123,
    height: 234,
    alt: 'asdfasdf'
  }
}

указывая в юрл дополнительную информацию, типа super.com|SuperCompany нарушается разделение модели и представления.

1. Возможно это плохая практика смешивать ссылку с названием компании
- пользователь должен видеть адрес ссылки
- название должно быть обычным цветом
- ссылку делать рядом с названием и в виде иконки или кнопки (если некрасиво показывать сам адрес)

2. Картинка с ссылкой
- обычно действует только для логотипа и только в хидере сайта
- хидер сайта должен содержать название продукта/услуги

Ссылки отображаются либо в виде текста (без https), либо заменяются на иконки уже непосредственно в стилях.


Форма для ввода данных
---

- веб-страницы ориентированы на взаимодействие с пользователем
- каждая веб-страница содержит элементы взаимодействия:
  - html forms
  - links
- несколько форм на одной веб-странице считается плохой практикой (форма комментария к видео, форма заказа услуги). По возможности разделяются формы на отдельные страницы
- одна форма - один тип взаимодействия (user interaction)
- примеры заполняемой сущности (формы):
  - заказ на услугу (подбор авиабилета, бронирование отеля)
  - комментарий/отзыв к статье/видео
- есть основная сущность (статья, видео, услуга), есть сущность взаимодействия (коммент, отзыв, заказ): отношение 1 к 1 - типичная схема для данной методологии


FormEntity
---

- предназначена для пользовательского взаимодействия - генерации формы
- может иметь несколько калькулируемых полей (например дата окончания = дата начала + 1 год)
- может содержать внутри себя внутренние сущности (массивы или объекты), например Форма оформления страхового Полиса содержит список Туристов и сущность Страхователя. Данные подсущности имитируют поведение вложенных форм, но в итоге содержатся в единой форме. Имена полей таких подсущностей содержат полные пути относительно корневой формы: insurants[1].name, insurer.age


TargetEntity and FormEntity
---

- FormEntity имеет ссылку на TargetEntity (1 к 1). TargetEntity может объединять другие сущности, но она должна быть единой точкой входа (одна на страницу)
- FormEntity необходима для заполнения и в основном не содержит данных. Соответственно не содержит микроразметки. Все инпуты помечаются атрибутом name, соответствующим названию поля.
- Форма может частично заполнятся на основе таких пользовательских данных, как параметры адресной строки и данные из локальных хранилищ браузера
- FormEntity по возможности также соответствует schema.org
- TargetEntity содержит микроразметку - сущность для отображения с заполеннными данными.
- В динамических приложениях при изменении FormEntity автоматически перерасчитывается TargetEntity (подгружается по url?filtersFromForm, либо калькулируется на клиенте)


Входные данные в генератор
---

- На вход в генератор поступает единая связанная сущность (FormEntity + TargetEntity). Эта связка необходима для калькулирования в динамических приложениях.
- На основе этой связанной сущности строится общая разметка.
- Часть разметки, относящейся к целевой сущности выносится из формы. 
- Вычисляется TargetEntity по метаданным: computed (or computedAsync) + ref. Если найдено несколько или ноль сущностей, то переданы неправильные данные на вход. В генератор передаются метаданные либо просто название поля целевой сущности
- Данное разделение является чисто техническим решением (обособить форму от разметки основной сущности) и необходимо для корректной работы поисковых роботов и технологий, типа AMP.
